{"name":"fusonic-linq","tagline":"PHP implementation of LINQ","body":"fusonic-linq \r\n-----------------\r\n\r\n[![Build Status](https://travis-ci.org/fusonic/fusonic-linq.png)](https://travis-ci.org/fusonic/fusonic-linq)\r\n[![Total Downloads](https://poser.pugx.org/fusonic/linq/downloads.png)](https://packagist.org/packages/fusonic/linq)\r\n\r\nfusonic-linq is a PHP library inspired by the LINQ 2 Objects extension methods in .NET.\r\n\r\nFor a full introduction read my blog-post: http://www.fusonic.net/en/blog/2013/08/14/fusonic-linq-write-less-do-more/\r\n\r\nLINQ queries offer three main advantages over traditional foreach loops:\r\n\r\n* They are more concise and readable, especially when filtering multiple conditions.\r\n\r\n* They provide powerful filtering, ordering, and grouping capabilities with a minimum of application code.\r\n\r\n* In general, the more complex the operation you want to perform on the data, the more benefit you will realize by using LINQ instead of traditional iteration techniques.\r\n\r\n\r\nRequirements\r\n------------\r\n\r\nfusonic-linq is supported on PHP 5.3 and up.\r\n\r\n\r\nInstallation & Usage\r\n------------\r\n\r\nThe most flexible installation method is using Composer: Simply create a composer.json file in the root of your project:\r\n``` json\r\n{\r\n    \"require\": {\r\n        \"fusonic/linq\": \"@dev\"\r\n    }\r\n}\r\n```\r\n\r\nInstall composer and run install command:\r\n``` bash\r\ncurl -s http://getcomposer.org/installer | php\r\nphp composer.phar install\r\n``` \r\n\r\nOnce installed, include vendor/autoload.php in your script to autoload fusonic-linq.\r\n\r\n``` php\r\nrequire 'vendor/autoload.php';\r\nuse Fusonic\\Linq\\Linq;\r\n\r\nLinq::from(array())->count();\r\n```\r\n\r\nExamples\r\n-----\r\n\r\n#### Calculate the average file size of files in a directory:\r\n``` php\r\n$source = glob(\"files/*\");\r\nLinq::from($source)\r\n  ->select(function($i) { return filesize($i); })\r\n  ->average();\r\n```\r\n\r\n#### Find all files bigger than 1024 bytes and return the fileinfo object:\r\n``` php\r\n$source = glob(\"files/*\");\r\nLinq::from($source)\r\n  ->where(function($i) { return filesize($i) > 1024; })\r\n  ->select(function($i) { return pathinfo($i); });\r\n```\r\n\r\n#### Search for all users containing \"Max 1\", Skip 5 items, Take 2 items and select the property ID of each user:\r\n```php\r\n$result = Linq::from($users)\r\n    ->where(function (User $u) { return strstr($u->surname, \"Max 1\");  })\r\n    ->skip(5)\r\n    ->take(2)\r\n    ->select(function (User $u) { return $u->usrId; });\r\n```\r\n\r\n#### Flatten multiple sequences into one sequence:\r\n```php\r\n$array1 = array(\"key\" => \"a\", \"data\" => array(\"a1\", \"a2\"));\r\n$array2 = array(\"key\" => \"b\", \"data\" => array(\"b1\", \"b2\"));\r\n$array3 = array(\"key\" => \"c\", \"data\" => array(\"c1\", \"c2\"));\r\n\r\n$allArrays = array($array1, $array2, $array3);\r\n\r\n$result = Linq::from($allArrays)\r\n    ->selectMany(function($x) { return $x[\"data\"]; })\r\n    ->toArray();\r\n    \r\n// $result is now: array(\"a1\", \"a2\", \"b1\", \"b2\", \"c1\", \"c2\");\r\n\r\n```\r\n#### Map sequence to array with key/value selectors:\r\n```php\r\n$category1 = new stdClass(); $category1->key = 1; $category1->value = \"Cars\";\r\n$category2 = new stdClass(); $category2->key = 2; $category2->value = \"Ships\";\r\n\r\n$result = Linq::from(array($category1, $category2))\r\n    ->toArray(\r\n        function($x) { return $x->key; }, // key-selector\r\n        function($x) { return $x->value; } // value-selector\r\n    );\r\n            \r\n// $result is now: array(1 => \"Cars\", 2 => \"Ships\");\r\n```\r\n\r\n#### The aggregate method makes it simple to perform a calculation over a sequence of values:\r\n```php\r\n$numbers = Linq::from(array(1,2,3,4));\r\n$sum = $numbers->aggregate(function($a, $b) { return $a + $b; });\r\n// echo $sum; // output: 10 (1+2+3+4)\r\n\r\n$chars = Linq::from(array(\"a\", \"b\", \"c\"));\r\n$csv = $chars->aggregate(function($a, $b) { return $a . \",\" . $b; });\r\n// echo $csv; // output: \"a,b,c\"\r\n\r\n$chars = Linq::from(array(\"a\", \"b\", \"c\"));\r\n$csv = $chars->aggregate(function($a, $b) { return $a . \",\" . $b; }, \"seed\");\r\n// echo $csv; // output: \"seed,a,b,c\"\r\n\r\n```\r\n\r\n\r\n#### The chunk method makes it simple to split a sequence into chunks of a given size:\r\n```php\r\n$chunks = Linq::from(array(\"a\",\"b\",\"c\",\"d\",\"e\"))->chunk(2);\r\n$i = 0;\r\nforeach($chunk in $chunks) {\r\n  $i++;\r\n  echo \"Row $i <br>\";\r\n  foreach($char in $chunk) {\r\n    echo $char . \"|\";\r\n  }\r\n}\r\n// Result:\r\n// Row 1\r\n// a|b\r\n// Row 2\r\n// c|d\r\n// Row 3\r\n// e|\r\n\r\n```\r\n\r\n\r\nList of methods provided by fusonic-linq:\r\n-------------\r\n```php\r\naggregate($func, $seed = null) // Applies an accumulator function over a sequence.\r\nall($func) // Determines wheter all elements satisfy a condition.\r\nany($func) // Determines wheter any element satisfies a condition.\r\naverage($func = null) // Computes the average of all numeric values.\r\nconcat($second) // Concatenates 2 sequences\r\ncontains($value) // Determines whether a sequence contains a specified element.\r\ncount() // Counts the elements of the sequence.\r\nchunk($chunksize) // Splits the sequence in chunks according to $chunksize.\r\nexcept($second) // Returns all items except the ones of the given sequence.\r\ndistinct($func = null) // Returns all distinct items of a sequence using the optional selector.\r\neach($func) // Performs the specified action on each element of the sequence.\r\nelementAt($index) // Returns the element at a specified index or throws an exception.\r\nelementAtOrNull($index) // Returns the element at a specified index or returns null\r\nfirst($func = null) // Returns the first element that satisfies a specified condition or throws an exception.\r\nfirstOrNull($func = null) // Returns the first element, or NULL if the sequence contains no elements.\r\ngroupBy($keySelector) // Groups the object according to the $keySelector generated key.\r\nintersect($second) // Intersects the Linq sequence with second Iterable sequence.\r\nlast($func = null) // Returns the last element that satisfies a specified condition or throws an exception.\r\nlastOrNull($func = null) // Returns the last element that satisfies a condition or NULL if no such element is found.\r\nmax($func = null) //  Returns the maximum item value according to $func.\r\nmin($func = null) //  Returns the minimum item value according to $func\r\norderBy($func) // Sorts the elements in ascending order according to a key provided by $func.\r\norderByDescending($func) // Sorts the elements in descending order according to a key provided by $func.\r\nselect($func) // Projects each element into a new form by invoking the selector function.\r\nselectMany($func) // Projects each element of a sequence to a new Linq and flattens the resulting sequences into one sequence. \r\nsingle($func = null) // Returns the only element that satisfies a specified condition or throws an exception.\r\nsingleOrDefault($func = null) // Returns the only element that satisfies a specified condition or returns Null.\r\nskip($count) // Bypasses a specified number of elements and then returns the remaining elements.\r\nsum($func = null) // Gets the sum of all items or by invoking a transform function on each item to get a numeric value.\r\ntake($count) // Returns a specified number of contiguous elements from the start of a sequence.\r\ntoArray($keySelector=null, $valueSelector=null) // Creates an Array from this Linq object with an optional key selector.\r\nwhere($func) // Filters the Linq object according to func return result.\r\n```\r\n\r\nSimple, Consistent and Predictable\r\n-------------\r\n\r\nOne important design goal was the principle of the least surprise. As PHP is a fully dynamic language with nearly no type-safety, it is common to shoot yourself into the foot because of accidentally mixing up incompatible types.\r\n\r\nWe protect you from these programing errors by asserting that every callback functions you supply to the library must return a correctly typed value. In addition, every supported aggregate function will throw an exception if you are accidentally mixing up incompatible types.\r\n\r\nThis means that we made this library totally predictable in what it does, and verified that every function has its defined exceptions which are thrown when certain operations fail, or if certain types are not correct.\r\n\r\n```php\r\n/* Throws an UnexpectedValueException if the \r\nprovided callback function does not return a boolean */\r\nLinq::from(array(\"1\", \"1\"))\r\n->where(function($x) { return \"NOT A BOOLEAN\"; });\r\n\r\n/* Throws an UnexpectedValueException if one of the values\r\nis not convertible to a numeric value:*/\r\nLinq::from(array(1, 2, \"Not a numeric value\"))\r\n->sum();\r\n```\r\n\r\n\r\n\r\n\r\nRunning tests\r\n-------------\r\n\r\nYou can run the test suite with the following command:\r\n\r\n```bash\r\nphpunit --bootstrap tests/bootstrap.php .\r\n``` \r\n\r\n","google":"UA-6104857-19","note":"Don't delete this file! It's used internally to help with page regeneration."}